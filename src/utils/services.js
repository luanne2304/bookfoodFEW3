import Web3 from "web3";
import contractData from "../contracts/Bookfood.json"

const abi = contractData.abi;
const contractAddress = "0x38dda5a302b6b882d1550bd8a4fefc628320bba0";

const initContract = async (useWebsocket = false) => {
    // URL cho HTTP provider
    const rpcURL = "https://data-seed-prebsc-1-s1.binance.org:8545/";
    // URL cho WebSocket provider (BSC Testnet WebSocket)
    const wsURL = "wss://bsc-testnet.publicnode.com";

    // Ch·ªçn provider theo y√™u c·∫ßu
    const web3 = useWebsocket 
        ? new Web3(new Web3.providers.WebsocketProvider(wsURL))
        : new Web3(new Web3.providers.HttpProvider(rpcURL));
    
    // T·∫°o t√†i kho·∫£n t·ª´ private key
    const privateKey = localStorage.getItem("privateKey");
    if (!privateKey) {
        throw new Error("Private Key ch∆∞a ƒë∆∞·ª£c nh·∫≠p!");
    }
    const account = web3.eth.accounts.privateKeyToAccount(`0x${privateKey}`);
    web3.eth.accounts.wallet.add(account);
    
    // Kh·ªüi t·∫°o contract
    const contract = new web3.eth.Contract(abi, contractAddress);
    
    return { web3, contract, account };
};

const sendTransaction = async (methodName, ...params) => {
    try {
        const { web3, contract, account } = await initContract();
        const method = methodName(...params);
        const gas = await method.estimateGas({ from: account.address });
        const gasWithBuffer = gas * 12n / 10n;
        const txData = await method.send({ from: account.address, gas: gasWithBuffer });
        console.log("Giao d·ªãch th√†nh c√¥ng:", txData);
        return txData;
    } catch (error) {
        console.error("L·ªói giao d·ªãch:", error);
        throw error;    
    }
};

const services = {
    createRestaurant: async (name, houseNumber, street, ward, district, city, ownerAddress) => {
        const { contract } = await initContract();
        return sendTransaction(contract.methods.addRestaurant, name, houseNumber, street, ward, district, city, ownerAddress);
    },

    createCategory: async (name) => {
        const { contract } = await initContract();
        return sendTransaction(contract.methods.addCategory, name);
    },

    getAllCategories: async () => {
        const { contract } = await initContract();
        try {
            return await contract.methods.getAllCategory().call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y danh s√°ch ph√¢n lo·∫°i:", error);
            return [];
        }
    },

    getAllRestaurants: async () => {
        const { contract } = await initContract();
        try {
            return await contract.methods.getAllRestaurants().call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y danh s√°ch nh√† h√†ng:", error);
            return [];
        }
    },

    getOrder: async (id) => {
        const { contract } = await initContract();
        try {
            return await contract.methods.orders(id).call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y ƒë∆°n h√†ng:", error);
            return [];
        }
    },

    getRes: async (id) => {
        const { contract } = await initContract();
        try {
            return await contract.methods.restaurants(id).call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y nh√† h√†ng:", error);
            return [];
        }
    },

    getAllFoods: async () => {
        const { contract } = await initContract();
        try {
            return await contract.methods.getAllFoods().call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y danh s√°ch th·ª©c ƒÉn:", error);
            return [];
        }
    },

    getAllOrders: async () => {
        const { contract } = await initContract();
        try {
            return await contract.methods.getAllOrders().call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y danh s√°ch ƒë∆°n h√†ng:", error);
            return [];
        }
    },

    getOrderHistory: async () => {
        const { contract, account } = await initContract();
        try {
            return await contract.methods.getOrdersBySender().call({ from: account.address });
        } catch (error) {
            console.error("L·ªói khi l·∫•y l·ªãch s·ª≠ ƒë∆°n h√†ng:", error);
            return [];
        }
    },

    getOrderDetail: async (id) => {
        const { contract } = await initContract();
        try {
            return await contract.methods.getOrderDetails(id).call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y chi ti·∫øt ƒë∆°n h√†ng:", error);
            return [];
        }
    },

    updateOrderStatus: async (orderId, status) => {
        const { contract } = await initContract();
        return sendTransaction(contract.methods.updateOrderStatus, orderId, status);
    },

    rating: async (id, reviews, star) => {
        const { contract } = await initContract();
        return sendTransaction(contract.methods.addRating, id, reviews, star);
    },

    createFood: async (name, idres, cate, price, isVegan, isGlutenFree,img) => {
        const { contract } = await initContract();
        return sendTransaction(contract.methods.addFood, name, idres, cate, price, isVegan, isGlutenFree,img);
    },

    createOrder: async (payment, _foodIds, _quantities, UsePoint, note) => {
        const { contract } = await initContract();
        return sendTransaction(contract.methods.placeOrder, payment, _foodIds, _quantities, UsePoint, note);
    },

    searchFood: async (keyword) => {
        const { contract } = await initContract();
        try {
            return await contract.methods.searchFood(keyword).call();
        } catch (error) {
            console.error("L·ªói khi t√¨m ki·∫øm m√≥n ƒÉn:", error);
            return [];
        }
    },

    searchRestaurants: async (keyword) => {
        const { contract } = await initContract();
        try {
            return await contract.methods.searchRestaurants(keyword).call();
        } catch (error) {
            console.error("L·ªói khi t√¨m ki·∫øm nh√† h√†ng:", error);
            return [];
        }
    },

    getRatingByID: async (id) => {
        const { contract } = await initContract();
        try {
            return await contract.methods.getRatingsForFood(id).call();
        } catch (error) {
            console.error("L·ªói khi l·∫•y ƒë√°nh gi√°:", error);
            return [];
        }
    },

    chat: async (to, mess) => {
        const { contract } = await initContract();
        return sendTransaction(contract.methods.sendMessage, to, mess);
    },

    payment: async (id, value) => {
        const { web3, contract, account } = await initContract();
        
        try {
            const formattedValue = (parseFloat(value) / 1000).toString();
            const weiValue = web3.utils.toWei(formattedValue, "ether");
            const method = contract.methods.processPayment(id);
            const gas = await method.estimateGas({ 
                from: account.address, 
                value: weiValue 
            });
            
            const txData = await method.send({ 
                from: account.address, 
                gas: gas * 12n / 10n, 
                value: weiValue 
            });
            
            console.log("Giao d·ªãch thanh to√°n th√†nh c√¥ng:", txData);
            return txData;
        } catch (error) {
            console.error("L·ªói khi thanh to√°n:", error);
            throw error;
        }
    },

    listenForMessages: async (callback) => {
        try {
            // S·ª≠ d·ª•ng WebSocket provider cho events
            const { contract, account } = await initContract(true);
            
            if (!contract || !account) {
                console.error("L·ªói: Contract ho·∫∑c account ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.");
                return;
            }
            
            console.log("ƒêang l·∫Øng nghe tin nh·∫Øn cho ƒë·ªãa ch·ªâ:", account.address);
            
            contract.events.MessageSent()
            .on("data", (event) => {
                console.log("üì© Nh·∫≠n ƒë∆∞·ª£c s·ª± ki·ªán tin nh·∫Øn:", event);

                const { receiver, sender, message } = event.returnValues;
                console.log(`üí¨ G·ª≠i t·ª´ ${sender} ƒë·∫øn ${receiver}: ${message}`);

                if (receiver.toLowerCase() === account.address.toLowerCase()) {
                    console.log("‚úÖ Tin nh·∫Øn ƒë·∫øn ƒë√∫ng ng∆∞·ªùi nh·∫≠n:", { sender, message });
                    callback({ sender, message });
                }
            })
            .on("error", (error) => {
                console.error("üö® L·ªói khi l·∫Øng nghe s·ª± ki·ªán tin nh·∫Øn:", error);
            });
        } catch (error) {
            console.error("L·ªói khi thi·∫øt l·∫≠p listener tin nh·∫Øn:", error);
        }
    },

    listenForUpdateOrder: async (callback) => {
        try {
            // B·∫Øt bu·ªôc d√πng WebSocket Provider
            const { contract, account } = await initContract(true);
            if (!contract || !account) {
                console.error("L·ªói: Contract ho·∫∑c account ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.");
                return;
            }
    
            console.log("üì° ƒêang l·∫Øng nghe c·∫≠p nh·∫≠t ƒë∆°n h√†ng cho ƒë·ªãa ch·ªâ:", account.address);
    
            contract.events.OrderStatusUpdated()
                .on("data", (event) => {
                    console.log("üì© Nh·∫≠n ƒë∆∞·ª£c s·ª± ki·ªán c·∫≠p nh·∫≠t ƒë∆°n h√†ng:", event);
    
                    const { orderId, customer, status } = event.returnValues;
                    console.log(`üì¶ ƒê∆°n h√†ng ${orderId} c·ªßa ${customer} -> Tr·∫°ng th√°i: ${status}`);
    
                    if (customer.toLowerCase() === account.address.toLowerCase()) {
                        let statusText = {
                            "0": "ƒêang ch·ªù x√°c nh·∫≠n",
                            "1": "ƒêang chu·∫©n b·ªã m√≥n",
                            "2": "ƒê√£ giao"
                        }[status] || "Kh√¥ng x√°c ƒë·ªãnh";
    
                        console.log("‚úÖ ƒê∆°n h√†ng c·∫≠p nh·∫≠t:", { orderId, statusText });
    
                        callback({ sender: "H·ªá th·ªëng", message: `üì¶ ƒê∆°n h√†ng #${orderId} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t: ${statusText}` });
                    }
                })
                .on("error", (error) => {
                    console.error("üö® L·ªói khi l·∫Øng nghe s·ª± ki·ªán c·∫≠p nh·∫≠t ƒë∆°n h√†ng:", error);
                });
        } catch (error) {
            console.error("üö® L·ªói khi thi·∫øt l·∫≠p listener ƒë∆°n h√†ng:", error);
        }
    },
    
};

export default services;